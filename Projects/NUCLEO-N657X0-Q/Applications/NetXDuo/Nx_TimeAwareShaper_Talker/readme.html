<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Readme</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../../../../_htmresc/mini-st_2020.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="row">
<section id="nx_timeawareshaper_talker-application-description"
class="col-sm-12 col-lg-8">
<h2><b>Nx_TimeAwareShaper_Talker Application Description</b></h2>
<p>This application provides an example of Azure RTOS NetX/NetXDuo stack
usage. It is used to demonstrate the effect of the Time-Aware Shaper
(IEEE 802.1Qbv standard) on Ethernet transmission behavior.</p>
<p>The main entry function tx_application_define() is then called by
ThreadX during kernel start, at this stage, all NetX resources are
created.</p>
<ul>
<li>A <i> NX_PACKET_POOL </i> is allocated</li>
<li>A <i>NX_IP</i> instance using that pool is initialized</li>
<li>The <i>ARP</i>, <i>ICMP</i>, <i>UDP</i> and <i>TCP</i> protocols are
enabled for the <i>NX_IP</i> instance</li>
</ul>
<p>The application creates an IP instance with a static address
<code>NX_APP_DEFAULT_IP_ADDRESS</code>, which will transmit normal
frames via <code>ETH_QUEUE_0</code> It also creates a secondary
interface with a static address <code>NX_APP_SECOND_IP_ADDRESS</code>,
which will transmit tagged frames (VLAN = 2) via
<code>ETH_QUEUE_1</code>. It launches a thread that creates two UDP
sockets and starts sending UDP packets infinitely via
<code>ETH_QUEUE_0</code> and <code>ETH_QUEUE_1</code> The TAS feature is
disabled at the beginning of the application. When the user presses the
user button, the TAS feature is enabled.</p>
<p>The TAS feature is configured via these parameters in
<code>app_netxduo.h</code>: - <code>TAS_CYCLE_TIME</code> -
<code>QUEUE_1_SLOT_TIME</code> - <code>QUEUE_0_SLOT_TIME</code> -
<code>QUEUE_0_SLOT_OFFSET</code></p>
<h4 id="expected-success-behavior"><b>Expected success behavior</b></h4>
<ul>
<li>The board IP address is printed on the HyperTerminal.</li>
<li>Start messages transmission: <code>DEFAULT_MESSAGE_Q0</code>
transmitted via <code>ETH_QUEUE_0</code> to
<code>SERVER_IP_ADDRESS</code> <code>DEFAULT_MESSAGE_Q1</code>
transmitted via <code>ETH_QUEUE_1</code> to
<code>SERVER_IP_SECOND_ADDRESS</code></li>
<li>In Wireshark launched on the remote PC (see required remote PC
configuration in the “How to use it” section), you will see that the
transmission is done in a standard way.</li>
<li>When the user presses the User button, the transmission is done via
slots according to the TAS configuration.</li>
<li>Below are the expected messages on the HyperTerminal:</li>
</ul>
<pre><code>Nx_TimeAwareShaper_Talker application started..
STM32 NX_APP_DEFAULT_IP_ADDRESS: 192.168.249.6
STM32 NX_APP_SECOND_IP_ADDRESS: 192.168.250.6

Time Aware Shaper Feature is Disabled
Press User Button to enable it

UDP transmission started...

Time Aware Shaper Feature is Enabled
Configuration Parameters in Nanoseconds :
 CYCLE TIME            = 1000000
 QUEUE 0 Slot Interval = 300000
 QUEUE 1 Slot Interval = 700000
</code></pre>
<h4 id="error-behaviors"><b>Error behaviors</b></h4>
<ul>
<li>The red LED is turned ON</li>
</ul>
<h4 id="assumptions-if-any"><b>Assumptions if any</b></h4>
<ul>
<li>The application is configuring the Ethernet IP with a static
predefined <i>MAC Address</i>, make sure to change it in case multiple
boards are connected on the same LAN to avoid any potential network
traffic issues.</li>
<li>The <i>MAC Address</i> is defined in the <code>main.c</code></li>
</ul>
<pre><code>void MX_ETH_Init(void)
{

  /* USER CODE BEGIN ETH_Init 0 */

  /* USER CODE END ETH_Init 0 */

  /* USER CODE BEGIN ETH_Init 1 */

  /* USER CODE END ETH_Init 1 */
  heth.Instance = ETH1;
  MACAddr[0] = 0x00;
  MACAddr[1] = 0x80;
  MACAddr[2] = 0xE0;
  MACAddr[3] = 0x00;
  MACAddr[4] = 0x10;
  MACAddr[5] = 0x00;</code></pre>
<h4 id="known-limitations"><b>Known limitations</b></h4>
<ul>
<li>Link managememnt thread is not implemented in this application. So,
the ETHERNET cable should be connected before running the example</li>
<li>Hardware reset is required sometimes to apply new TAS
configuration.</li>
</ul>
<h4 id="threadx-usage-hints"><b>ThreadX usage hints</b></h4>
<ul>
<li>ThreadX uses the Systick as time base, thus it is mandatory that the
HAL uses a separate time base through the TIM IPs.</li>
<li>ThreadX is configured with 100 ticks/sec by default, this should be
taken into account when using delays or timeouts at application. It is
always possible to reconfigure it, by updating the
“TX_TIMER_TICKS_PER_SECOND” define in the “tx_user.h” file. The update
should be reflected in “tx_initialize_low_level.S” file too.</li>
<li>ThreadX is disabling all interrupts during kernel start-up to avoid
any unexpected behavior, therefore all system related calls (HAL, BSP)
should be done either at the beginning of the application or inside the
thread entry functions.</li>
<li>ThreadX offers the “tx_application_define()” function, that is
automatically called by the tx_kernel_enter() API. It is highly
recommended to use it to create all applications ThreadX related
resources (threads, semaphores, memory pools…) but it should not in any
way contain a system API call (HAL or BSP).</li>
<li>Using dynamic memory allocation requires to apply some changes to
the linker file. ThreadX needs to pass a pointer to the first free
memory location in RAM to the tx_application_define() function, using
the “first_unused_memory” argument. This requires changes in the linker
files to expose this memory location.
<ul>
<li>For EWARM add the following section into the .icf file:</li>
</ul>
<pre><code>place in RAM_region    { last section FREE_MEM };</code></pre>
<ul>
<li>For MDK-ARM:</li>
</ul>
<pre><code>Either define the RW_IRAM1 region in the &quot;.sct&quot; file
or modify the line below in &quot;tx_initialize_low_level.S to match the memory region being used
LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|</code></pre>
<ul>
<li>For STM32CubeIDE add the following section into the .ld file:</li>
</ul>
<pre><code>._threadx_heap :
  {
     . = ALIGN(8);
     __RAM_segment_used_end__ = .;
     . = . + 64K;
     . = ALIGN(8);
   } &gt;RAM_D1 AT&gt; RAM_D1</code></pre></li>
</ul>
<h4 id="netx-duo-usage-hints"><b>NetX Duo usage hints</b></h4>
<ul>
<li>Depending on the application scenario, the total TX and RX
descriptors may need to be increased by updating respectively the
“ETH_TX_DESC_CNT” and “ETH_RX_DESC_CNT” in the “stm32n6xx_hal_conf.h”,
to guarantee the application correct behaviour, but this will cost extra
memory to allocate.</li>
<li>The NetXDuo application needs to allocate the <b> <i> NX_PACKET </i>
</b> pool in a dedicated section. Below is an example of the section
declaration for different IDEs.
<ul>
<li>For EWARM “.icf” file</li>
</ul>
<pre><code>define symbol __ICFEDIT_region_NXDATA_start__ = 0x341F1000;
define symbol __ICFEDIT_region_NXDATA_end__   = 0x341FFFFF;
define region NXApp_region  = mem:[from __ICFEDIT_region_NXDATA_start__ to __ICFEDIT_region_NXDATA_end__];
place in NXApp_region { section .NetXPoolSection};</code></pre>
<ul>
<li>For MDK-ARM add the following section into the .sct file:</li>
</ul>
<pre><code> RW_NXDriverSection 0x341F1000 0xF000  {
   *(.NetXPoolSection)
 }</code></pre>
<ul>
<li>For STM32CubeIDE add the following section into the .ld file:</li>
</ul>
<pre><code> .nx_data (NOLOAD):
 {
     . = ABSOLUTE(0x341F1000);
     *(.NetXPoolSection)

 } &gt;RAM</code></pre>
This section is then used in the <code> app_azure_rtos.c</code> file to
force the <code>nx_byte_pool_buffer</code> allocation.</li>
</ul>
<pre><code>      /* USER CODE BEGIN NX_Pool_Buffer */

      #if defined ( __ICCARM__ ) /* IAR Compiler */
      #pragma location = &quot;.NetXPoolSection&quot;

      #else /* GNU and AC6 compilers */
      __attribute__((section(&quot;.NetXPoolSection&quot;)))

      #endif

      /* USER CODE END NX_Pool_Buffer */
      static UCHAR  nx_byte_pool_buffer[NX_APP_MEM_POOL_SIZE];
      static TX_BYTE_POOL nx_app_byte_pool;</code></pre>
<p>For more details about the MPU configuration please refer to the <a
href="https://www.st.com/resource/en/application_note/dm00272912-managing-memory-protection-unit-in-stm32-mcus-stmicroelectronics.pdf">AN4838</a></p>
<h3 id="keywords"><b>Keywords</b></h3>
<p>RTOS, Network, ThreadX, NetXDuo, TSN, TAS, PTP, UART</p>
<h3 id="hardware-and-software-environment"><b>Hardware and Software
environment</b></h3>
<ul>
<li><p>This application runs on STM32N657xx devices.</p></li>
<li><p>This application has been tested with STMicroelectronics
NUCLEO-N657X0-Q boards Revision MB1940-N657XOQ-C01 and can be easily
tailored to any other supported device and development board.</p></li>
<li><p>This application uses USART1 to display logs, the hyperterminal
configuration is as follows:</p>
<ul>
<li>BaudRate = 115200 baud</li>
<li>Word Length = 8 Bits</li>
<li>Stop Bit = 1</li>
<li>Parity = None</li>
<li>Flow control = None</li>
</ul></li>
</ul>
<h3 id="how-to-use-it"><b>How to use it ?</b></h3>
<p>In order to make the program work, you must do the following :</p>
<ul>
<li>Set the boot mode in development mode (BOOT1 switch position is 2-3,
BOOT0 switch position doesn’t matter).</li>
<li>Rebuild all files and load your image into target memory. Code can
be executed in this mode for debugging purposes.</li>
<li>In remote PC you need to :
<ul>
<li>Create a new instance to handle tagged frames (vlan 2). Cmd Example
: sudo ip link add link eno1 name eno1.2 type vlan id 2</li>
<li>Address and netmask configuration. Cmd Example : sudo ifconfig
eno1.2 192.168.250.5 netmask 255.255.255.0 up</li>
<li>Run Wireshark application to capture packets received from
NX_APP_DEFAULT_IP_ADDRESS and NX_APP_SECOND_IP_ADDRESS.</li>
</ul></li>
<li>Launch the application</li>
</ul>
<p>Next, this program can be run in boot from flash mode. This can be
done by following the instructions below:</p>
<ul>
<li>Resort to CubeProgrammer to add a header to the generated binary
Project.bin with the following command
<ul>
<li><em>STM32_SigningTool_CLI.exe -bin Nx_TimeAwareShaper_Talker.bin -nk
-of 0x80000000 -t fsbl -o Nx_TimeAwareShaper_Talker_trusted.bin -hv 2.3
-dump Nx_TimeAwareShaper_Talker_trusted.bin</em>
<ul>
<li>The resulting binary is Nx_TimeAwareShaper_Talker_trusted.bin.</li>
</ul></li>
</ul></li>
<li>Next, in resorting again to CubeProgrammer, load the binary and its
header (Nx_TimeAwareShaper_Talker_trusted.bin) in Nucleo board external
Flash at address 0x7000’0000.</li>
<li>Set the boot mode in boot from external Flash (BOOT0 switch position
is 1-2 and BOOT1 switch position is 1-2).</li>
<li>Press the reset button. The code then executes in boot from external
Flash mode.</li>
</ul>
</section>
</div>
</body>
</html>
